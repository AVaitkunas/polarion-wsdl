// Code generated by gowsdl DO NOT EDIT.

package session_ws

import (
	"context"
	"encoding/xml"
	"time"

	"github.com/hooklift/gowsdl/soap"
)

// against "unused imports"
var (
	_ time.Time
	_ xml.Name
)

type AnyType struct {
	InnerXML string `xml:",innerxml"`
}

type AnyURI string

type NCName string

type BeginTransaction struct {
	XMLName xml.Name `xml:"http://ws.polarion.com/SessionWebService-impl beginTransaction"`
}

type BeginTransactionResponse struct {
	XMLName xml.Name `xml:"http://ws.polarion.com/SessionWebService-impl beginTransactionResponse"`
}

type EndSession struct {
	XMLName xml.Name `xml:"http://ws.polarion.com/SessionWebService-impl endSession"`
}

type EndSessionResponse struct {
	XMLName xml.Name `xml:"http://ws.polarion.com/SessionWebService-impl endSessionResponse"`
}

type EndTransaction struct {
	XMLName xml.Name `xml:"http://ws.polarion.com/SessionWebService-impl endTransaction"`

	Rollback bool `xml:"rollback,omitempty" json:"rollback,omitempty"`
}

type EndTransactionResponse struct {
	XMLName xml.Name `xml:"http://ws.polarion.com/SessionWebService-impl endTransactionResponse"`
}

type HasSubject struct {
	XMLName xml.Name `xml:"http://ws.polarion.com/SessionWebService-impl hasSubject"`
}

type HasSubjectResponse struct {
	XMLName xml.Name `xml:"http://ws.polarion.com/SessionWebService-impl hasSubjectResponse"`

	HasSubjectReturn bool `xml:"hasSubjectReturn,omitempty" json:"hasSubjectReturn,omitempty"`
}

type LogIn struct {
	XMLName xml.Name `xml:"http://ws.polarion.com/SessionWebService-impl logIn"`

	UserName string `xml:"userName,omitempty" json:"userName,omitempty"`

	Password string `xml:"password,omitempty" json:"password,omitempty"`
}

type LogInResponse struct {
	XMLName xml.Name `xml:"http://ws.polarion.com/SessionWebService-impl logInResponse"`
}

type LogInWithToken struct {
	XMLName xml.Name `xml:"http://ws.polarion.com/SessionWebService-impl logInWithToken"`

	Mechanism string `xml:"mechanism,omitempty" json:"mechanism,omitempty"`

	Username string `xml:"username,omitempty" json:"username,omitempty"`

	Token string `xml:"token,omitempty" json:"token,omitempty"`
}

type LogInWithTokenResponse struct {
	XMLName xml.Name `xml:"http://ws.polarion.com/SessionWebService-impl logInWithTokenResponse"`
}

type TransactionExists struct {
	XMLName xml.Name `xml:"http://ws.polarion.com/SessionWebService-impl transactionExists"`
}

type TransactionExistsResponse struct {
	XMLName xml.Name `xml:"http://ws.polarion.com/SessionWebService-impl transactionExistsResponse"`

	TransactionExistsReturn bool `xml:"transactionExistsReturn,omitempty" json:"transactionExistsReturn,omitempty"`
}

type SessionWebService interface {
	/*
		Starts a explicit transaction for the current session.
		Usually transactions are started and committed for each call to the webservice, but if a transaction has been started explicitly it also has to be terminated using endTransaction.    */
	BeginTransaction(request *BeginTransaction) (*BeginTransactionResponse, error)

	BeginTransactionContext(ctx context.Context, request *BeginTransaction) (*BeginTransactionResponse, error)

	/*
		Terminates the current session.    */
	EndSession(request *EndSession) (*EndSessionResponse, error)

	EndSessionContext(ctx context.Context, request *EndSession) (*EndSessionResponse, error)

	/*
		Ends the explicit transaction of the current session by either commit or rollback.
		@param rollback if true the transaction is rolled back otherwise it is commited.    */
	EndTransaction(request *EndTransaction) (*EndTransactionResponse, error)

	EndTransactionContext(ctx context.Context, request *EndTransaction) (*EndTransactionResponse, error)

	/*
		Checks if a user is logged in for the current session.    */
	HasSubject(request *HasSubject) (*HasSubjectResponse, error)

	HasSubjectContext(ctx context.Context, request *HasSubject) (*HasSubjectResponse, error)

	/*
		Logs a user in for the current session.
		@param userName the name of the user to log-in.
		@param password the password of the user to log-in.    */
	LogIn(request *LogIn) (*LogInResponse, error)

	LogInContext(ctx context.Context, request *LogIn) (*LogInResponse, error)

	/*
		This method works for both Teamcenter Security Services SSO and Personal Access Tokens (since Polarion 3.22.1).
		Possible (case insensitive) values for the mechanism parameters: TcSS and AccessToken.

		This will NOT work for the other SSO methods supported by Polarion. (Kerberos, SAML, or OAuth2.)
		For SAML, OAuth2 (or deprecated Kerberos), you should use the SessionWebService.logIn(username, password) method (LDAP configuration should be enabled for web services) or use an access token.

		@param mechanism the mechanism that the client requests for authentication. If the TcSS mechanism is used, the server must be configured for TcSS. (Otherwise, the login with this mechanism will be rejected.) AccessToken is always accepted.
		@param username the name of the user to login. Required for TcSS. null for AccessToken
		@param token the token of the user to login.
		@since 3.17.0    */
	LogInWithToken(request *LogInWithToken) (*LogInWithTokenResponse, error)

	LogInWithTokenContext(ctx context.Context, request *LogInWithToken) (*LogInWithTokenResponse, error)

	/*
		Check if there is a explicit transaction (started with beginTransaction) for the current session.    */
	TransactionExists(request *TransactionExists) (*TransactionExistsResponse, error)

	TransactionExistsContext(ctx context.Context, request *TransactionExists) (*TransactionExistsResponse, error)
}

type sessionWebService struct {
	client *soap.Client
}

func NewSessionWebService(client *soap.Client) SessionWebService {
	return &sessionWebService{
		client: client,
	}
}

func (service *sessionWebService) BeginTransactionContext(ctx context.Context, request *BeginTransaction) (*BeginTransactionResponse, error) {
	response := new(BeginTransactionResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *sessionWebService) BeginTransaction(request *BeginTransaction) (*BeginTransactionResponse, error) {
	return service.BeginTransactionContext(
		context.Background(),
		request,
	)
}

func (service *sessionWebService) EndSessionContext(ctx context.Context, request *EndSession) (*EndSessionResponse, error) {
	response := new(EndSessionResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *sessionWebService) EndSession(request *EndSession) (*EndSessionResponse, error) {
	return service.EndSessionContext(
		context.Background(),
		request,
	)
}

func (service *sessionWebService) EndTransactionContext(ctx context.Context, request *EndTransaction) (*EndTransactionResponse, error) {
	response := new(EndTransactionResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *sessionWebService) EndTransaction(request *EndTransaction) (*EndTransactionResponse, error) {
	return service.EndTransactionContext(
		context.Background(),
		request,
	)
}

func (service *sessionWebService) HasSubjectContext(ctx context.Context, request *HasSubject) (*HasSubjectResponse, error) {
	response := new(HasSubjectResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *sessionWebService) HasSubject(request *HasSubject) (*HasSubjectResponse, error) {
	return service.HasSubjectContext(
		context.Background(),
		request,
	)
}

func (service *sessionWebService) LogInContext(ctx context.Context, request *LogIn) (*LogInResponse, error) {
	response := new(LogInResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *sessionWebService) LogIn(request *LogIn) (*LogInResponse, error) {
	return service.LogInContext(
		context.Background(),
		request,
	)
}

func (service *sessionWebService) LogInWithTokenContext(ctx context.Context, request *LogInWithToken) (*LogInWithTokenResponse, error) {
	response := new(LogInWithTokenResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *sessionWebService) LogInWithToken(request *LogInWithToken) (*LogInWithTokenResponse, error) {
	return service.LogInWithTokenContext(
		context.Background(),
		request,
	)
}

func (service *sessionWebService) TransactionExistsContext(ctx context.Context, request *TransactionExists) (*TransactionExistsResponse, error) {
	response := new(TransactionExistsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *sessionWebService) TransactionExists(request *TransactionExists) (*TransactionExistsResponse, error) {
	return service.TransactionExistsContext(
		context.Background(),
		request,
	)
}
